package gretig;

import datastructures.DualGraph;
import datastructures.PlaneNodeArray;
import elements.Face;
import elements.Pair;
import elements.Plane;
import elements.PlaneNode;

/**
 * Object used for computing the yutsis decomposition of a 2-connected cubic graph in linear time with a greedy algorithm.
 * This algorithm uses ideas written in the paper "To be or not to be Yutsis: algorithms for the
   decision problem" written by D. Van Dyck, G. Brinkmann and V. Fack.
 */
public class YutsisDecomposer {
    private DualGraph graph;
    private PlaneNodeArray V; //Contains all nodes which aren't in M or L[]. Initially all nodes.
    private PlaneNodeArray M; //Contains all nodes of the current tree in the graph.
    /**
     * There are 3 L arrays: L[0], L[1] and L[2]. When adding a node to M, all neighbours of this node which are in V are added to
     * the correct L array. The index in the array of L arrays equals the amount of neighbours in V.
     */
    private PlaneNodeArray[] L;
    private PlaneNodeArray D; //Contains all nodes which aren't in M, these nodes also form a tree.

    /**
     * Initializes a new YutsisDecomposer object which is used for decomposing the given 2-connected cubic graph in 2 trees.
     * @param graph
     */
    public YutsisDecomposer(DualGraph graph){
        this.graph = graph;
        L = new PlaneNodeArray[3];
    }

    /**
     * Executes the actual greedy algorithm for finding 2 independent trees with half of the nodes each
     * of the dual graph of this decomposer.  The base of this algorithm is the algorithm described in the syllabus.
     * The algorithm is additionally inspired by the ideas of the paper "To be or not to be Yutsis: algorithms for the decision problem".
     * The algorithm works as following:
     *
     * Precondition:
     * ==============
     * - graph is 2-connected cubic graph.
     * - V contains all the nodes of this graph.
     *
     * Postcondition:
     * ==============
     * - This function returns a yutsis-decomposition if he was able to find one.
     *
     * Algorithm:
     * ==============
     * - v <- The first node in V
     * - Add v to M
     * - Update L arrays
     * - while any L array has nodes && M is not complete
     *      - i <- 0
     *      - while i>= 0 and !nodeFound
     *          - v is the node which was last added to L[i]
     *          - if v is addable (v has 1 neighbour in M and isn't a cutvertex)
     *              - add v to M
     *              - update L
     *              - nodeFound <- true
     *          - else
     *              - switch v from L[i] to V
     *
     *
     * @return The Yutsis-decomposition generated by the greedy algorithm
     */
    public PlaneNodeArray[] findYutsisDecomposition(){
        initializeYutsisArrays();
        //Note: Always remove a node first, before adding it to another array!
        int n = V.length();
        PlaneNode node = V.get(5);
        V.remove(node);
        M.add(node);
        for(Pair pair: node.getPairs()){
            if(!pair.isMarked()){
                pair.getFace().markPairs();
            }
        }
        update(node);
        boolean L_arrays_empty = false;
        //Unplaced neighbour: neighbours that are not yet contained in Li or the tree
        while(M.length() < n/2 && !L_arrays_empty){
            node = getHighestLNode(); //Finds the highest node with 1 neighbour in M.
            if(node!=null){
                Face face = node.isCutVertex(M);
                if(face==null){ //Node is a cutvertex.
                    node.switchTo(V);
                }
                else {
                    node.switchTo(M);
                    face.markPairs();
                    update(node);
                }
            }
            else {
                L_arrays_empty = true;
            }
            //Check if L arrays are empty.

        }
        return buildDecomposition(n); //Makes 2 independent trees from the sets.
    }

    public PlaneNode getHighestLNode() {
        int i = 2;
        while (i >= 0) {
            //The computation of the number of unplaced neighbours can obviously be done
            //in constant time and every vertex is tested and moved at most 3 times.
            if (L[i].length() > 0) {
                PlaneNode maxNode = L[i].peek();
                if (i > 0) {
                    //Check amount of unplaced neighbours
                    int unplacedNeighbourAmount = maxNode.neighbourAmount(V);

                    //If unplacedneighbourAmount isn't correct, switch this node to the correct L array.
                    if (unplacedNeighbourAmount != i) {
                        maxNode.switchTo(L[unplacedNeighbourAmount]);
                    } else {
                        if (maxNode.neighbourAmount(M) == 1) {
                            return maxNode;
                        }
                        else {
                            maxNode.switchTo(V);
                        }
                    }

                } else { //If i = 0, neighbourAmount doesn't have to be checked.
                    return maxNode;
                }
            } else {
                i--;
            }
        }
        return null;
    }

    public PlaneNodeArray[] buildDecomposition(int n){
        System.out.println(M.length() + "/" + n/2);
        boolean hasYutsisDecomposition = M.length() == n/2;
        if(hasYutsisDecomposition) {
            //Search elements which are not in M.
            for (int i = 0; i < V.length(); i++) {
                PlaneNode planeNode = V.get(i);
                if(planeNode!=null){
                    D.add(V.get(i));
                }
            }
            for(int j=0; j<3; j++){
                for (int i = 0; i < L[j].length(); i++) {
                    PlaneNode planeNode = L[j].get(i);
                    if(planeNode!=null){
                        D.add(L[j].get(i));
                    }
                }
            }

            hasYutsisDecomposition = hasYutsisDecomposition && D.length() == n / 2; //If both sets contain n nodes, there is a yutsis decomposition.
            if(!hasYutsisDecomposition){
                return null;
            }
            else {
                PlaneNodeArray[] yutsisdecomposition = new PlaneNodeArray[2];
                yutsisdecomposition[0] = M;
                yutsisdecomposition[1] = D;
                return yutsisdecomposition;
            }
        }
        return null;
    }

    private void update(PlaneNode node) {
        for(PlaneNode neighbour: node.getNeighbours()){
            int index = neighbour.neighbourAmount(V);
            if(!neighbour.isPresent(M)){
                /**
                 * 3 possible cases:
                 * neighbour is in V: place neighbour in the correct L array.
                 * neighbour is in the wrong L array: place neighbour in the correct L array.
                 * neighbour was in the correct L array:
                 */
                neighbour.switchTo(L[index]);
            }
        }
    }


    private void initializeYutsisArrays() {
        V = new PlaneNodeArray("V", graph.getSize());
        M = new PlaneNodeArray("M", graph.getSize()/2);
        for(int j=0; j<3; j++){
            L[j] = new PlaneNodeArray("L" + j,graph.getSize());
        }
        D = new PlaneNodeArray("D", graph.getSize()/2);
        for(Plane plane: graph.getPlanes()){ //Linear time, and is called once.
            if(plane!=null){
                V.add(plane.getNode());
            }
        }
    }
}
