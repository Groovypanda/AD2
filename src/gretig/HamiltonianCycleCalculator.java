package gretig;

import datastructures.DualGraph;
import datastructures.Graph;
import datastructures.YutsisArray;
import elements.*;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by Jarre on 18/11/2016.
 */
public class HamiltonianCycleCalculator {
    private DualGraph dualGraph;
    public static int i = 0;

    public HamiltonianCycleCalculator(Graph graph) {
        this.dualGraph = new DualGraph(graph);
        //As the dualgraph contains 2n-4 nodes (the amount of planes). We can try to make a yutsis decomposition.
        PlaneNode[][] D = findYutsisDecomposition();
        if(D!=null){
            //System.out.println("Cykel gevonden");
        }
        else{
            System.out.println("Cykel niet gevonden");
            i++;
        }
    }


    //Gebaseerd op het algoritme uit de syllabus.
    public PlaneNode[][] findYutsisDecomposition(){
        initializeYutsisArrays();
        YutsisArray V = YutsisArray.V;
        YutsisArray M = YutsisArray.M;
        YutsisArray L = YutsisArray.L;
        //Note: Always remove a node first, before adding it to another array!
        int n = V.length();
        M.initialize(n/2); //M can't contain more than n/2 elements.
        L.initialize(n);
        PlaneNode node = V.get(0);
        V.remove(node);
        M.add(node);
        update(node);
        while(M.length() < n/2 && L.length() >0){
            //In the original find yutsis algorithm, the max node of L is taken. This has a linear time complexity.
            //We can only use constant methods inside this while loop. So we look for the maximum neighbour of the last added
            //element to M. As there are only 3 neighbours, this method is constant.
            PlaneNode max = node.getMaxNeighbour(V); //Returns null if the node has 0 neighbours in V.
            if(max == null){
                max = L.get(0); //If doesn't have any addable neighbours, a random one is chosen from the L set. (The first one)
            }
            YutsisArray.values()[max.getArrayNumber()].remove(max); //Remove max from his current array.
            M.add(max);
            update(max);
        }

        boolean hasYutsisDecomposition = M.length() == n/2;
        if(hasYutsisDecomposition) {
            PlaneNode[][] D = new PlaneNode[2][n/2]; //The 2 disjunct parts generated by the yutsis decomposition algorithm.
            D[0] = M.getNodes();
            int index = 0;
            //Search elements which are not in M.
            for (int i = 0; i < V.length() && index < n; i++) {
                D[1][index++] = V.get(i);
            }
            for (int i = 0; i < L.length() && index < n; i++) {
                D[1][index++] = L.get(i);
            }
            hasYutsisDecomposition = hasYutsisDecomposition && index == n / 2; //If both sets contain n nodes, there is a yutsis decomposition.
            if (hasYutsisDecomposition) {
                return D;
            }
        }
        return null;
    }

    /**
     * Updates the L set.
     * @param node The element which was last added to M.
     * @return The new size of L.
     */
    public void update(PlaneNode node){
        YutsisArray L = YutsisArray.L;
        YutsisArray V = YutsisArray.V;
        YutsisArray M = YutsisArray.M;
        for(Plane neighbour: node.getPlane().getAdjacentPlanes()){ //3 iterations
            PlaneNode neighbourNode = neighbour.getNode();
            if(!neighbourNode.isPresent(M)){
                int neighbours = neighbourNode.neighbourAmount(M);
                if(!neighbourNode.isPresent(L) && !neighbourNode.isPresent(M)){
                    if(neighbours < 2){
                        V.remove(neighbourNode);
                        L.add(neighbourNode);
                    }
                }
                else if(neighbours >=2){
                    L.remove(neighbourNode);
                    V.add(neighbourNode);
                }
            }
        }
    }

    private void initializeYutsisArrays() {
        YutsisArray array = YutsisArray.V;
        array.initialize(dualGraph.getSize());
        for(Plane plane: dualGraph.getPlanes()){ //Linear time, and is called once.
            array.add(plane.getNode());
        }
    }

    public Cycle getCycle(){
        Cycle cycle = new Cycle(graph.getNodes().length);
        initiateCycle(cycle, graph.getEdges()[3]);
        //cycle.printCycle(false);
        List<CycleEdge> addedCycleEdges = new ArrayList<>();
        List<CycleEdge> removedCycleEdges = new ArrayList<>();
        while(!cycle.isComplete()){
            //System.out.println("==== Iteration =====");
            while(cycle.hasVisibleNext()){
                CycleEdge visibleCurrent = cycle.visibleNext();
                //System.out.println(visibleCurrent);
                Edge[] plane = getAdjacentPlane(visibleCurrent.getEdge());
                boolean isAddable = !plane[1].getCommonNode(plane[2]).visited() && !plane[1].isVisited()
                        && !plane[2].isVisited() && cycle.getSize() < graph.getNodes().length;
                if(isAddable){
                    //Create the 2 new CycleEdges.
                    CycleEdge current1 = new CycleEdge(plane[1]);
                    CycleEdge current2 = new CycleEdge(plane[2]);
                    //Add them to the cycle.
                    addCycleEdges(cycle, visibleCurrent, current1, current2);
                    //Add them to the added list.
                    addedCycleEdges.add(current1);
                    addedCycleEdges.add(current2);
                }
                else {
                    //Delete visibleCurrent from visible CycleEdges.
                    removeVisibleCycleEdge(cycle, visibleCurrent);
                    removedCycleEdges.add(visibleCurrent);
                }
            }
            //If no edges can't be visited anymore, we have to stop.
            if(addedCycleEdges.size()==0){
                return cycle;
            }
            //Amount of iterations are less or equal to the amount of (inner) while loop iterations of the previous loop.
            for(CycleEdge addedCycleEdge: addedCycleEdges){
                addedCycleEdge.update();
            }
            cycle.update();
            addedCycleEdges.clear();
            removedCycleEdges.clear();
            //cycle.printCycle(false);
            //cycle.printVisibleCycle();
        }

        return cycle;
    }

}
