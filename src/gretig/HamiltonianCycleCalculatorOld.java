package gretig;

import cycle.Cycle;
import cycle.CycleEdge;
import graph.Edge;
import graph.Graph;

import java.util.ArrayList;
import java.util.List;

/**
 * My old greedy algorithm for finding cycles in a graph. This doesn't work as good as the new version
 * (HamiltonianCycleCalculator). For graphs with size 12 it finds a cycle 76%  of the times while the new algorithm
 * finds a cycle 92% of the times. This class works with 3 types of cycleEdges:
 * - realCycleEdge: Represents an edge in the current cycle.
 * - visibleCycleEdge: Represent an edge which can be checked by the algorithm in the current cycle.
 * - tmpVisibleCycleEdge: Represents an updated version of the visibleCycleEdges. These visible cycle edges can't be changed
 *   in place as the algorithm performs better by iterating trough the visible edges only and adding the new ones once the loop
 *   trough the current visible edges has finished.
 */
public class HamiltonianCycleCalculatorOld {
    private Graph graph;
    public static int total = 0; //Keeps track of the total amount of attempts to generate a cycle in this class.
    public static int succesful = 0; //Keeps track of the amount of succesful cycles generated by this class.

    /**
     * Constructor for the old HamiltonianCycleCalculator.
     * @param graph The graph of which the cycle should be computed.
     */
    public HamiltonianCycleCalculatorOld(Graph graph) {
        this.graph = graph;
    }

    /**
     * Prints a cycle to stdout. If this cycle doesn't contain all of the nodes it will print "Geen cykel gevonden".
     * @param cycle The cycle to be printed.
     */
    public void printCycle(Cycle cycle){
        total++;
        if(cycle.isComplete()){
            cycle.printCycle();
            System.out.println();
            succesful++;
        }
        else {
            System.out.println("Geen cykel gevonden.");
        }
    }

    /**
     * Calculates a cycle with a greedy linear algorithm.
     * One note before explaining the algorithm:
     * In a cycle there are basically 2 kinds of cycleEdges (edges in a cycle).
     * The edges which are visible, and all of the edges.
     * An edge which isn't visible, can't be used to expand the cycle.
     *
     * The algorithm operates as follows:
     *
     * Precondition:
     * =============
     * - A triangular graph
     *
     * Postcondition:
     * =============
     * - Computed (an approximation of) a hamiltonian cycle.
     *
     * Algorithm:
     * ==========
     * - Create a cycle with 0 nodes.
     * - Start with a random plane and add its nodes to the cycle.
     * - While the cycle isn't complete and there are visible edges.
     *      - for every visible edge in the current cycle:
     *          - plane <- the plane adjacent to this edge such that the given plane isn't inside the current cycle yet.
     *          - If the other 2 edges of this plane aren't visited yet and the other node which isn't in the cycle isn't added yet:
     *                  - Add these 2 edges (and their common node) to the cycle and visit them.
     *          - else:
     *                  - Remove this edge from the visible edges.
     *
     * @return A cycle which might not be complete (= contain all of the nodes of the graph).
     */
    public Cycle calculateCycle(){
        Cycle cycle = new Cycle(graph.getNodes().length);
        initiateCycle(cycle, graph.getEdges()[3]);
        List<CycleEdge> addedCycleEdges = new ArrayList<>();
        List<CycleEdge> removedCycleEdges = new ArrayList<>();
        while(!cycle.isComplete()){
            while(cycle.hasVisibleNext()){
                CycleEdge visibleCurrent = cycle.visibleNext(); //Gets the first visible cycleEdge
                //Get the plane adjacent to this edge so that it's not contained in the current cycle.
                Edge[] plane = getAdjacentPlane(visibleCurrent.getEdge());
                boolean isAddable = !plane[1].getCommonNode(plane[2]).visited() && !plane[1].isVisited()
                        && !plane[2].isVisited() && cycle.getSize() < graph.getNodes().length; //Check if it's addable.
                if(isAddable){
                    //Create the 2 new CycleEdges.
                    CycleEdge current1 = new CycleEdge(plane[1]);
                    CycleEdge current2 = new CycleEdge(plane[2]);
                    //Add them to the cycle.
                    addCycleEdges(cycle, visibleCurrent, current1, current2);
                    //Add them to the added list.
                    addedCycleEdges.add(current1);
                    addedCycleEdges.add(current2);
                }
                else {
                       //Delete visibleCurrent from visible CycleEdges.
                    removeVisibleCycleEdge(cycle, visibleCurrent);
                    removedCycleEdges.add(visibleCurrent);
                }
            }
            //If no edges can't be visited anymore, we have to stop.
            if(addedCycleEdges.size()==0){
                return cycle;
            }
            //Amount of iterations are less or equal to the amount of (inner) while loop iterations of the previous loop.
            for(CycleEdge addedCycleEdge: addedCycleEdges){
                addedCycleEdge.update();
            }
            cycle.update();
            addedCycleEdges.clear();
            removedCycleEdges.clear();
        }

        return cycle;
    }

    /**
     * Removes the given cycleEdge from the visible cycleEdges in the given cycle.
     * @param cycle
     * @param toRemove This cycleEdge will be removed from the visible cycles.
     */
    private void removeVisibleCycleEdge(Cycle cycle, CycleEdge toRemove) {
        toRemove.getTmpVisiblePrevious().setTmpVisibleNext(toRemove.getTmpVisibleNext());
        toRemove.getTmpVisibleNext().setTmpVisiblePrevious(toRemove.getTmpVisiblePrevious());
        checkCycleHeadAndTail(cycle, toRemove, toRemove.getRealPrevious());
        checkVisibleCycleHeadAndTail(cycle, toRemove, toRemove.getTmpVisiblePrevious());
    }

    /**
     * Replaces one edge (toRemove) with its adjacent edges (toAdd1 and toAdd2). These new edges
     * are also added to the visible edges.
     * @param cycle
     * @param toRemove The edge which has to be removed.
     * @param toAdd1 First replacing edge.
     * @param toAdd2 Second replacing edge.
     */
    private void addCycleEdges(Cycle cycle, CycleEdge toRemove, CycleEdge toAdd1, CycleEdge toAdd2) {
        //Add the cycleEdge to the cycle.
        cycle.add(toRemove.getRealPrevious(), toAdd1, toAdd2, toRemove.getRealNext());
        //Update the temporary visible values. These values will be used as visible cycleEdges after looping over the current
        //visible values.
        toAdd1.setTmpVisiblePrevious(toRemove.getTmpVisiblePrevious());
        toAdd1.setTmpVisibleNext(toAdd2);
        toAdd2.setTmpVisiblePrevious(toAdd1);
        toAdd2.setTmpVisibleNext(toRemove.getTmpVisibleNext());
        toRemove.getTmpVisiblePrevious().setTmpVisibleNext(toAdd1);
        toRemove.getTmpVisibleNext().setTmpVisiblePrevious(toAdd2);
        //Check if any head or tail isn't in the cycle anymore.
        checkCycleHeadAndTail(cycle, toRemove, toAdd1);
        checkVisibleCycleHeadAndTail(cycle, toRemove, toAdd1);
    }

    public Edge[] getAdjacentPlane(Edge edge){
        Edge[] plane = new Edge[3];
        plane[0] = edge;
        plane[1] = plane[0].getNextEdge(plane[0].getNodes()[0]);
        plane[2] = plane[0].getPreviousEdge(plane[0].getNodes()[1]);
        if(plane[1].isVisited() && plane[2].isVisited()){
            plane[1] = plane[0].getNextEdge(plane[0].getNodes()[1]);
            plane[2] = plane[0].getPreviousEdge(plane[0].getNodes()[0]);
        }
        return plane;
    }

    /**
     * Initiates a new cycle with 3 nodes and 3 edges which are part of one of the adjacent planes of the given edge.
     * @param cycle The cycle which has to be initialized.
     * @param start The edge from where we have to start building a new cycle.
     */
    public void initiateCycle(Cycle cycle, Edge start){
        CycleEdge[] cycleEdges = new CycleEdge[3];
        cycleEdges[0] = new CycleEdge(start);
        cycleEdges[1] = new CycleEdge(start.getNextEdge(start.getNodes()[1]));
        cycleEdges[2] = new CycleEdge(start.getPreviousEdge(start.getNodes()[0]));
        cycle.add(cycleEdges[0], cycleEdges[1], cycleEdges[2]);
        for(CycleEdge cycleEdge: cycleEdges){
            cycleEdge.setVisiblePrevious(cycleEdge.getRealPrevious());
            cycleEdge.setTmpVisiblePrevious(cycleEdge.getRealPrevious());
            cycleEdge.setVisibleNext(cycleEdge.getRealNext());
            cycleEdge.setTmpVisibleNext(cycleEdge.getRealNext());
        }
        cycle.setHead(cycleEdges[0]);
        cycle.setTail(cycleEdges[2]);
        cycle.setVisibleHead(cycleEdges[0]);
        cycle.setVisibleTail(cycleEdges[2]);
    }

    /**
     * Checks if the head and the tail of the given cycle are correct by checking if the last removed edge: current
     * equals the head or tail in the cycle. If so, it will be replaced by new head and its previous edge.
     * @param cycle
     * @param current The last removed cycleEdge.
     * @param newHead The replacement for the head if necessary.
     */
    public void checkCycleHeadAndTail(Cycle cycle, CycleEdge current, CycleEdge newHead){
        if(cycle.getRealHead().equals(current) || cycle.getTmpRealHead().equals(current) ||
                cycle.getRealTail().equals(current) || cycle.getTmpRealTail().equals(current)){
            cycle.setTmpRealHead(newHead);
            cycle.setTmpRealTail(newHead.getRealPrevious());
        }
    }

    /**
     * Visible version of the checkCycleHeadAndTail method, checks if the visible head and the visible tail in a cycle
     * are correct by checking if the last removed edge: current equals the visible head or visible tail in the cycle.
     * If so, it will be replaced by the new head and its previous edge.
     * @param cycle
     * @param current The last removed edge.
     * @param newHead The new edge if necessary.
     */

    public void checkVisibleCycleHeadAndTail(Cycle cycle, CycleEdge current, CycleEdge newHead){
        if(cycle.getVisibleHead().equals(current) || cycle.getTmpVisibleHead().equals(current) ||
                cycle.getVisibleTail().equals(current) || cycle.getTmpVisibleTail().equals(current)){
            cycle.setTmpVisibleHead(newHead);
            cycle.setTmpVisibleTail(newHead.getTmpVisiblePrevious());
        }
    }
}
